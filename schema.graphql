"""
A Swap entity represents an atomic swap of one token for another token
on Ambient.
"""
type Swap @entity(immutable: true) {
  "unique id for the swap transaction"
  id: Bytes!

  "transaction hash"
  hash: Bytes!
  "unique index which increments upward from zero for every unique pair of (event/entity type, transaction hash)"
  callIndex: Int!
  "transaction timestamp"
  timestamp: BigInt!
  "block number"
  block: BigInt!

  "user address"
  user: Bytes!

  "liquidity pool that the swap was executed on"
  pool: Pool!

  "base token amount change in the pool - negative indicates a credit that the caller received"
  baseFlow: BigInt!
  "quote token amount change in the pool - negative indicates a credit that the caller received"
  quoteFlow: BigInt!

  "finalized price of the swap calculated on baseFlow/quoteFlow, beware of decimal differences"
  price: BigDecimal
}

"""
A Pool represents a single liquidity pool on CrocSwap, which is uniquely
specified by a base token, a quote token, and a poolIdx.
"""
type Pool @entity {
  "poolHash used internally in CrocSwap contracts"
  id: Bytes!
  "base token entity"
  base: Token!
  "quote token entity"
  quote: Token!
  "poolIdx used for the pool"
  poolIdx: BigInt!

  "total volume of base token traded in the pool"
  baseVolume: BigInt!
  "total volume of quote token traded in the pool"
  quoteVolume: BigInt!

  "swap entities associated with this pool"
  swaps: [Swap!]! @derivedFrom(field: "pool")
}

"""
A Token entity represents a token that is traded on CrocSwap.
"""
type Token @entity {
  "unique id for the token contract address"
  id: Bytes!
  "token decimals"
  decimals: BigInt!

  "total volume of the token traded across all pools"
  totalVolume: BigInt!
}

"""
LatestIndex entities are used to help perform bookkeeping related to the
generation of unique event IDs in the case where multiple identical entities
would otherwise be created within the same transaction.
"""
type LatestIndex @entity {
  id: Bytes!
  callIndex: Int!
}

"""
Reflects sequences of changes necessary to accurately calculate aggregate statistics
such as volume, TVL and fees collected
"""
type AggEvent @entity(immutable: true) {
  id: Bytes!
  transactionHash: Bytes!
  eventIndex: Int!
  pool: Pool!
  block: BigInt!
  time: BigInt!
  baseFlow: BigInt
  quoteFlow: BigInt
  isSwap: Boolean!
  isLiq: Boolean!
  isFeeChange: Boolean!
  swapPrice: BigDecimal
  inBaseQty: Boolean!
  isTickSkewed: Boolean!
  flowsAtMarket: Boolean!
  bidTick: Int
  askTick: Int
  feeRate: Int
}
